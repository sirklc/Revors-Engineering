#!/usr/bin/env python3
"""
Advanced Multi-Language Decompiler
Assembly kodundan orijinal kaynak kodunu (Python, C++, etc.) çıkarır
"""

import os
import sys
import re
import struct
from pathlib import Path
from tools.language_detector import LanguageDetector

class AdvancedDecompiler:
    def __init__(self, file_path, output_dir="extracted/source_code"):
        self.file_path = file_path
        self.output_dir = output_dir
        self.file_data = None
        self.detected_language = None
        self.confidence = 0
        self.strings = []
        self.functions = []
        
        os.makedirs(output_dir, exist_ok=True)
        
    def detect_language(self):
        """Dil tespiti yap"""
        detector = LanguageDetector(self.file_path)
        result = detector.analyze()
        
        if result:
            self.detected_language = result['primary_language']
            self.confidence = result['confidence']
            self.strings = detector.strings
            return True
        return False
    
    def decompile_python(self):
        """Python kaynak kodunu reconstruct et"""
        file_base = os.path.splitext(os.path.basename(self.file_path))[0]
        output_file = os.path.join(self.output_dir, f"{file_base}_reconstructed.py")
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("#!/usr/bin/env python3\n")
            f.write('"""\n')
            f.write(f"Reconstructed Python code from {os.path.basename(self.file_path)}\n")
            f.write("Generated by Advanced Decompiler\n")
            f.write('"""\n\n')
            
            # Import statements reconstruction
            imports = self.extract_python_imports()
            if imports:
                f.write("# Detected imports\n")
                for imp in imports:
                    f.write(f"{imp}\n")
                f.write("\n")
            
            # Constants reconstruction
            constants = self.extract_python_constants()
            if constants:
                f.write("# Detected constants\n")
                for const in constants:
                    f.write(f"{const}\n")
                f.write("\n")
            
            # Function reconstruction
            functions = self.extract_python_functions()
            if functions:
                f.write("# Reconstructed functions\n")
                for func in functions:
                    f.write(f"{func}\n\n")
            
            # Main execution
            main_patterns = [s for s in self.strings if '__main__' in s or 'main(' in s]
            if main_patterns:
                f.write('if __name__ == "__main__":\n')
                f.write('    # Main execution logic\n')
                f.write('    main()\n')
            
            # Error handling
            f.write('\n# Note: This is a reconstructed approximation\n')
            f.write('# Original code may differ significantly\n')
        
        return output_file
    
    def extract_python_imports(self):
        """Python import statements çıkar"""
        imports = []
        
        # Common Python modules
        python_modules = [
            'sys', 'os', 're', 'json', 'urllib', 'requests', 'numpy', 'pandas',
            'matplotlib', 'tkinter', 'PyQt5', 'flask', 'django', 'sqlite3',
            'threading', 'multiprocessing', 'subprocess', 'datetime', 'time',
            'random', 'math', 'collections', 'itertools', 'functools'
        ]
        
        detected_modules = []
        for string in self.strings:
            for module in python_modules:
                if module in string.lower() and len(string) < 50:
                    if module not in detected_modules:
                        detected_modules.append(module)
        
        # Generate import statements
        for module in detected_modules[:15]:  # Limit to first 15
            imports.append(f"import {module}")
        
        # Specific patterns
        for string in self.strings:
            if re.match(r'^from\s+\w+\s+import\s+\w+', string):
                imports.append(string)
            elif re.match(r'^import\s+\w+', string):
                imports.append(string)
        
        return imports[:20]  # Limit
    
    def extract_python_constants(self):
        """Python constants çıkar"""
        constants = []
        
        # String constants
        string_constants = [s for s in self.strings if 10 < len(s) < 100 and s.isprintable()]
        for i, const in enumerate(string_constants[:10]):
            safe_name = re.sub(r'[^a-zA-Z0-9_]', '_', const[:20]).upper()
            constants.append(f'{safe_name} = "{const}"')
        
        # Numeric patterns
        numeric_patterns = []
        for string in self.strings:
            numbers = re.findall(r'\b\d+\b', string)
            numeric_patterns.extend(numbers)
        
        # Common numeric constants
        common_numbers = ['8080', '443', '80', '3306', '5432', '27017']
        for num in common_numbers:
            if num in numeric_patterns:
                constants.append(f"PORT_{num} = {num}")
        
        return constants
    
    def extract_python_functions(self):
        """Python function'ları reconstruct et"""
        functions = []
        
        # Common function patterns
        function_patterns = [
            ('main', 'def main():\n    """Main function"""\n    pass'),
            ('init', 'def __init__(self):\n    """Initialize object"""\n    pass'),
            ('connect', 'def connect(self, host, port):\n    """Connect to server"""\n    pass'),
            ('send', 'def send(self, data):\n    """Send data"""\n    pass'),
            ('receive', 'def receive(self):\n    """Receive data"""\n    pass'),
            ('process', 'def process(self, data):\n    """Process data"""\n    pass'),
            ('handle', 'def handle_request(self, request):\n    """Handle request"""\n    pass')
        ]
        
        # Check which patterns exist in strings
        detected_functions = []
        for pattern_name, template in function_patterns:
            if any(pattern_name in s.lower() for s in self.strings):
                detected_functions.append(template)
        
        # Generate class if OOP patterns detected
        oop_indicators = ['class', 'self', '__init__', 'object']
        if any(indicator in ' '.join(self.strings).lower() for indicator in oop_indicators):
            class_name = os.path.splitext(os.path.basename(self.file_path))[0].title()
            class_template = f'''class {class_name}:
    """Reconstructed class"""
    
    def __init__(self):
        """Initialize the class"""
        self.initialized = True
    
    def run(self):
        """Main execution method"""
        pass'''
            functions.append(class_template)
        
        return functions + detected_functions
    
    def decompile_cpp(self):
        """C++ kaynak kodunu reconstruct et"""
        file_base = os.path.splitext(os.path.basename(self.file_path))[0]
        output_file = os.path.join(self.output_dir, f"{file_base}_reconstructed.cpp")
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("/*\n")
            f.write(f" * Reconstructed C++ code from {os.path.basename(self.file_path)}\n")
            f.write(" * Generated by Advanced Decompiler\n")
            f.write(" */\n\n")
            
            # Headers
            headers = self.extract_cpp_headers()
            if headers:
                for header in headers:
                    f.write(f"#include {header}\n")
                f.write("\n")
            
            # Namespace
            f.write("using namespace std;\n\n")
            
            # Constants
            constants = self.extract_cpp_constants()
            if constants:
                for const in constants:
                    f.write(f"{const}\n")
                f.write("\n")
            
            # Function declarations
            functions = self.extract_cpp_functions()
            if functions:
                for func in functions:
                    f.write(f"{func}\n\n")
            
            # Main function
            f.write("int main(int argc, char* argv[]) {\n")
            f.write("    // Reconstructed main function\n")
            f.write("    cout << \"Program started\" << endl;\n")
            f.write("    \n")
            f.write("    // Main logic would be here\n")
            f.write("    \n")
            f.write("    return 0;\n")
            f.write("}\n")
        
        return output_file
    
    def extract_cpp_headers(self):
        """C++ header'ları çıkar"""
        headers = []
        
        # Standard C++ headers
        std_headers = [
            'iostream', 'vector', 'string', 'map', 'set', 'algorithm',
            'memory', 'fstream', 'sstream', 'thread', 'mutex', 'chrono'
        ]
        
        # Windows headers
        win_headers = ['windows.h', 'winsock2.h', 'wininet.h']
        
        detected_headers = set()
        
        for string in self.strings:
            for header in std_headers:
                if header in string.lower():
                    detected_headers.add(f"<{header}>")
            for header in win_headers:
                if header.lower() in string.lower():
                    detected_headers.add(f"<{header}>")
        
        return list(detected_headers)[:10]
    
    def extract_cpp_constants(self):
        """C++ constants çıkar"""
        constants = []
        
        # Common constants
        for string in self.strings:
            if re.match(r'^[A-Z_]+$', string) and 3 < len(string) < 20:
                constants.append(f"const char* {string} = \"{string}\";")
        
        return constants[:10]
    
    def extract_cpp_functions(self):
        """C++ function'ları reconstruct et"""
        functions = []
        
        # Common function templates
        function_templates = [
            'void initialize() {\n    // Initialize application\n}',
            'bool connect(const string& host, int port) {\n    // Connect to server\n    return true;\n}',
            'void cleanup() {\n    // Cleanup resources\n}',
            'int processData(const void* data, size_t size) {\n    // Process data\n    return 0;\n}'
        ]
        
        return function_templates
    
    def decompile_dotnet(self):
        """C# (.NET) kaynak kodunu reconstruct et"""
        file_base = os.path.splitext(os.path.basename(self.file_path))[0]
        output_file = os.path.join(self.output_dir, f"{file_base}_reconstructed.cs")
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("/*\n")
            f.write(f" * Reconstructed C# code from {os.path.basename(self.file_path)}\n")
            f.write(" * Generated by Advanced Decompiler\n")
            f.write(" */\n\n")
            
            # Using statements
            usings = [
                "using System;",
                "using System.Collections.Generic;",
                "using System.IO;",
                "using System.Text;",
                "using System.Threading.Tasks;"
            ]
            
            for using in usings:
                f.write(f"{using}\n")
            f.write("\n")
            
            # Namespace
            namespace = file_base.replace('-', '_').replace(' ', '_')
            f.write(f"namespace {namespace}\n{{\n")
            
            # Main class
            f.write("    public class Program\n    {\n")
            f.write("        public static void Main(string[] args)\n        {\n")
            f.write("            // Reconstructed main method\n")
            f.write("            Console.WriteLine(\"Application started\");\n")
            f.write("            \n")
            f.write("            // Main logic would be here\n")
            f.write("            \n")
            f.write("        }\n")
            f.write("    }\n")
            f.write("}\n")
        
        return output_file
    
    def decompile_go(self):
        """Go kaynak kodunu reconstruct et"""
        file_base = os.path.splitext(os.path.basename(self.file_path))[0]
        output_file = os.path.join(self.output_dir, f"{file_base}_reconstructed.go")
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("/*\n")
            f.write(f"Reconstructed Go code from {os.path.basename(self.file_path)}\n")
            f.write("Generated by Advanced Decompiler\n")
            f.write("*/\n\n")
            
            f.write("package main\n\n")
            
            # Imports
            imports = ['fmt', 'os', 'log']
            f.write("import (\n")
            for imp in imports:
                f.write(f'    "{imp}"\n')
            f.write(")\n\n")
            
            # Main function
            f.write("func main() {\n")
            f.write('    fmt.Println("Go application started")\n')
            f.write("    \n")
            f.write("    // Main logic would be here\n")
            f.write("    \n")
            f.write("}\n")
        
        return output_file
    
    def decompile_java(self):
        """Java kaynak kodunu reconstruct et"""
        file_base = os.path.splitext(os.path.basename(self.file_path))[0]
        output_file = os.path.join(self.output_dir, f"{file_base}_reconstructed.java")
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("/*\n")
            f.write(f" * Reconstructed Java code from {os.path.basename(self.file_path)}\n")
            f.write(" * Generated by Advanced Decompiler\n")
            f.write(" */\n\n")
            
            # Package and imports
            f.write("import java.io.*;\n")
            f.write("import java.util.*;\n")
            f.write("import java.net.*;\n\n")
            
            # Main class
            class_name = file_base.replace('-', '_').replace(' ', '_').title()
            f.write(f"public class {class_name} {{\n\n")
            
            # Main method
            f.write("    public static void main(String[] args) {\n")
            f.write("        // Reconstructed main method\n")
            f.write('        System.out.println("Java application started");\n')
            f.write("        \n")
            f.write("        // Main logic would be here\n")
            f.write("        \n")
            f.write("    }\n")
            f.write("}\n")
        
        return output_file
    
    def analyze_and_decompile(self):
        """Ana decompile fonksiyonu"""
        print(f"🔄 ADVANCED DECOMPILATION: {os.path.basename(self.file_path)}")
        print("=" * 80)
        
        # Language detection
        if not self.detect_language():
            print("❌ Language detection failed")
            return None
        
        print(f"🎯 Detected Language: {self.detected_language} ({self.confidence}% confidence)")
        
        if self.confidence < 30:
            print("⚠️  Low confidence, attempting generic decompilation...")
        
        # Decompile based on detected language
        decompiler_map = {
            'Python': self.decompile_python,
            '.NET/C#': self.decompile_dotnet,
            'C/C++': self.decompile_cpp,
            'Go': self.decompile_go,
            'Java': self.decompile_java,
            'Node.js': self.decompile_javascript
        }
        
        output_files = []
        
        # Primary decompilation
        if self.detected_language in decompiler_map:
            try:
                primary_file = decompiler_map[self.detected_language]()
                output_files.append(primary_file)
                print(f"✅ {self.detected_language} decompilation: {os.path.basename(primary_file)}")
            except Exception as e:
                print(f"❌ {self.detected_language} decompilation failed: {e}")
        
        # If low confidence, try multiple approaches
        if self.confidence < 50:
            print(f"🔄 Attempting additional decompilations due to low confidence...")
            
            # Try most common languages
            common_languages = ['Python', 'C/C++', '.NET/C#']
            for lang in common_languages:
                if lang != self.detected_language and lang in decompiler_map:
                    try:
                        additional_file = decompiler_map[lang]()
                        output_files.append(additional_file)
                        print(f"✅ Additional {lang} decompilation: {os.path.basename(additional_file)}")
                    except Exception as e:
                        print(f"⚠️  {lang} decompilation failed: {e}")
        
        # Generate summary
        self.generate_decompilation_summary(output_files)
        
        return output_files
    
    def decompile_javascript(self):
        """JavaScript/Node.js kaynak kodunu reconstruct et"""
        file_base = os.path.splitext(os.path.basename(self.file_path))[0]
        output_file = os.path.join(self.output_dir, f"{file_base}_reconstructed.js")
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("/*\n")
            f.write(f" * Reconstructed JavaScript code from {os.path.basename(self.file_path)}\n")
            f.write(" * Generated by Advanced Decompiler\n")
            f.write(" */\n\n")
            
            # Node.js requires
            f.write("const fs = require('fs');\n")
            f.write("const path = require('path');\n")
            f.write("const http = require('http');\n\n")
            
            # Main function
            f.write("function main() {\n")
            f.write("    console.log('Node.js application started');\n")
            f.write("    \n")
            f.write("    // Main logic would be here\n")
            f.write("    \n")
            f.write("}\n\n")
            
            f.write("// Start the application\n")
            f.write("if (require.main === module) {\n")
            f.write("    main();\n")
            f.write("}\n")
        
        return output_file
    
    def generate_decompilation_summary(self, output_files):
        """Decompilation özeti oluştur"""
        summary_file = os.path.join(self.output_dir, "DECOMPILATION_SUMMARY.md")
        
        with open(summary_file, 'w', encoding='utf-8') as f:
            f.write("# Advanced Decompilation Summary\n\n")
            f.write(f"**Source File:** {os.path.basename(self.file_path)}\n")
            f.write(f"**Detected Language:** {self.detected_language}\n")
            f.write(f"**Confidence:** {self.confidence}%\n")
            f.write(f"**Generated Files:** {len(output_files)}\n\n")
            
            f.write("## Generated Source Files\n\n")
            for file_path in output_files:
                file_name = os.path.basename(file_path)
                file_size = os.path.getsize(file_path)
                f.write(f"- **{file_name}** ({file_size:,} bytes)\n")
            
            f.write("\n## Important Notes\n\n")
            f.write("⚠️ **DISCLAIMER:** These are reconstructed approximations of the original source code.\n\n")
            f.write("- The original code structure may differ significantly\n")
            f.write("- Variable and function names are generated/guessed\n")
            f.write("- Logic flow is simplified and may not match the original\n")
            f.write("- Use these files as a starting point for analysis\n\n")
            
            f.write("## Recommended Tools\n\n")
            f.write("For better results, consider using:\n")
            f.write("- **Python:** uncompyle6, decompyle3\n")
            f.write("- **C/C++:** Ghidra, IDA Pro, Radare2\n")
            f.write("- **.NET:** dnSpy, ILSpy, Reflexil\n")
            f.write("- **Java:** JD-GUI, Procyon, CFR\n")
            f.write("- **Go:** GoReverseEngineering\n")
        
        print(f"📋 Decompilation summary: {summary_file}")

def main():
    if len(sys.argv) < 2:
        print("Kullanım: python advanced_decompiler.py <exe_dosyasi> [output_dir]")
        print("\nBu araç assembly kodundan orijinal kaynak kodunu çıkarmaya çalışır:")
        print("  🐍 Python (PyInstaller, py2exe)")
        print("  🔷 C# (.NET Framework)")  
        print("  ⚡ C/C++ (MSVC, GCC)")
        print("  🐹 Go (Go compiler)")
        print("  ☕ Java (Launch4j wrapper)")
        print("  🟢 Node.js (pkg, nexe)")
        sys.exit(1)
    
    file_path = sys.argv[1]
    output_dir = sys.argv[2] if len(sys.argv) > 2 else "extracted/source_code"
    
    if not os.path.exists(file_path):
        print(f"❌ Dosya bulunamadı: {file_path}")
        sys.exit(1)
    
    decompiler = AdvancedDecompiler(file_path, output_dir)
    result = decompiler.analyze_and_decompile()
    
    if result:
        print(f"\n🎉 Decompilation completed!")
        print(f"📂 Output directory: {output_dir}")
        print(f"📄 Generated files: {len(result)}")
        for file_path in result:
            print(f"   - {os.path.basename(file_path)}")
    else:
        print(f"\n❌ Decompilation failed")

if __name__ == "__main__":
    main()